location {{ route }} {
    resolver {{ resolver }} valid=60s;

    # Set the "matched_backend" variable so that the "/auth/" location can
    # send it to Turnpike.
    set $matched_backend {{ name }};

    # Set a custom "upstream" variable so that the origin's resolution doesn't
    # happen at startup. The goal is to delay the resolution of the upstream
    # services, so that the ones that are offline don't prevent Nginx from
    # booting for the rest of the services that are online.
    set $upstream {{ origin }};

    # Delegate authentication to the "/auth/" location as soon as this
    # location is matched.
    auth_request /auth/;

    # When receiving the authentication response from the Flask application,
    # if the response contains the "X-Rh-Identity" header, set it as a
    # variable so that we can send its value to the upstream service.
    auth_request_set $turnpike_x_rh_identity $upstream_http_x_rh_identity;

    # Rewrite the URI that we are going to send to the upstream server.
    #
    # We strip the route part and we get the rest of the path from the incoming request. For example, for a
    # back end defined like so...
    #
    # - Origin: http://my-service.svc.local:8080/endpoint/
    # - Route: /api/my-service/endpoint
    #
    # ... and a request sent to "/api/my-service/endpoint/resource/subresource", we strip the route prefix from
    # the request and capture the rest of the path, "/resource/subresource", to append it to the origin when
    # sending it to the upstream service. Therefore, Nginx, after authenticating the request, would end up
    # sending a request to "http://my-service.svc.local:8080/endpoint/resource/subresource".
    #
    # The reason why this is not done with a regex location instead is because when we have back ends defined
    # which have overlapping URLs, Nginx just returns on the first matched regex location. Therefore, with the
    # following defined locations...
    #
    # - location ~ /api/base
    # - location ~ /api/base/path-a/
    # - location ~ /api/base/path-a/subpath-a
    #
    # ... and a request sent to "/api/base/path-a/subpath-a/subsubpath-a", Nginx would match the first regex
    # location. The only reason we had regex locations in the past was to be able to remove the route prefix
    # from the requests and append the rest of it to the origin for the "proxy_pass" directive, because no one
    # was really using regex locations for anything else. And we can achieve the same thing by rewriting the
    # URI before passing it to "proxy_pass".
    #
    # The reason to prepend the "$upstream" variable is because if we have the following location...
    #
    # - location /api/test
    #
    # ... and a request is sent to "/api/test" without anything else, the capture group will be empty and then
    # Nginx complains with a "the rewritten URI has zero length" error. Prepending the "$upstream" variable
    # ensures that the rewritten URI will always have, at least, the upstream's URL and therefore the rewrite
    # will never be empty.
    rewrite {{ route }}(.*)$ $upstream$1$is_args$args break;

    # Once authentication has been completed, send the request to the upstream
    # service with all the defined extra
    # headers here.
    proxy_pass          $uri;
    proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;
    proxy_set_header    X-Forwarded-Host    $host;
    proxy_set_header    X-Forwarded-Port    443;
    proxy_set_header    X-Forwarded-Proto   https;
    proxy_set_header    X-Original-URI      $request_uri;
    proxy_set_header    X-Real-IP           $remote_addr;

    # Send the "X-RH-Identity" header to the upstream service if Turnpike returned
    # it after the authentication.
    proxy_set_header    X-RH-Identity       $turnpike_x_rh_identity;
}
